{"meta":{"title":"奔跑的蜗牛","subtitle":null,"description":null,"author":"奔跑的蜗牛","url":"http://wangweijin.cn","root":"/"},"pages":[{"title":"about","date":"2018-04-19T12:55:13.000Z","updated":"2020-01-20T10:14:11.419Z","comments":false,"path":"about/index.html","permalink":"http://wangweijin.cn/about/index.html","excerpt":"","text":"个人简介王巍瑾 男河南科技学院|15级|计算机科学与技术"},{"title":"分类","date":"2018-04-19T07:47:24.000Z","updated":"2020-01-20T10:14:11.419Z","comments":false,"path":"categories/index.html","permalink":"http://wangweijin.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-19T07:46:58.000Z","updated":"2020-01-20T10:14:11.419Z","comments":false,"path":"tags/index.html","permalink":"http://wangweijin.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"3. 无重复字符的最长子串","slug":"2020-07-12-2","date":"2020-07-12T06:10:58.000Z","updated":"2020-07-12T06:18:48.951Z","comments":true,"path":"2020/07/12/2020-07-12-2/","link":"","permalink":"http://wangweijin.cn/2020/07/12/2020-07-12-2/","excerpt":"一、题目LeetCode题目《无重复字符的最长子串》 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。","text":"一、题目LeetCode题目《无重复字符的最长子串》 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 二、代码12345678910111213141516171819func lengthOfLongestSubstring(s string) int &#123; l, r, n := 0, 0, 0 sLen := len(s) m := make(map[byte]struct&#123;&#125;, sLen/2) for r &lt; sLen &#123; if _, ok := m[s[r]]; !ok &#123; m[s[r]] = struct&#123;&#125;&#123;&#125; r += 1 if len(m) &gt; n &#123; n = len(m) &#125; continue &#125; delete(m, s[l]) l += 1 &#125; return n&#125; 三、思路 滑动模块思想，当一段字符串无重复时，只需要保证新添加进来的字符串无重复，不需要要每次验证是否重复 使用map保存滑块，方便验证滑块是否存在重复","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://wangweijin.cn/categories/LeetCode/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://wangweijin.cn/tags/哈希表/"},{"name":"双指针","slug":"双指针","permalink":"http://wangweijin.cn/tags/双指针/"},{"name":"字符串","slug":"字符串","permalink":"http://wangweijin.cn/tags/字符串/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://wangweijin.cn/tags/Sliding-Window/"}]},{"title":"2. 两数相加","slug":"2020-07-12-1","date":"2020-07-11T16:37:10.000Z","updated":"2020-07-11T17:03:44.229Z","comments":true,"path":"2020/07/12/2020-07-12-1/","link":"","permalink":"http://wangweijin.cn/2020/07/12/2020-07-12-1/","excerpt":"一、题目LeetCode题目《两数相加》 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字0之外，这两个数都不会以0开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807","text":"一、题目LeetCode题目《两数相加》 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字0之外，这两个数都不会以0开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 二、代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil &amp;&amp; l2 == nil &#123; return nil &#125; var ( l = new(ListNode) n, sum int ) result := l for &#123; sum = n if l1 != nil &#123; sum += l1.Val l1 = l1.Next &#125; if l2 != nil &#123; sum += l2.Val l2 = l2.Next &#125; n = sum / 10 l.Val = sum % 10 if n == 0 &#123; if l1 == nil &amp;&amp; l2 == nil &#123; break &#125; if l1 != nil &amp;&amp; l2 == nil &#123; l.Next = l1 break &#125; if l2 != nil &amp;&amp; l1 == nil &#123; l.Next = l2 break &#125; &#125; l.Next = new(ListNode) l = l.Next &#125; return result&#125; 三、思路 加法器的思路，个位与个位相加，逢十进一 当其中1个链表为空并且没有进位，可以直接用第二个链表Next附加到最终值","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://wangweijin.cn/categories/LeetCode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://wangweijin.cn/tags/链表/"},{"name":"数学","slug":"数学","permalink":"http://wangweijin.cn/tags/数学/"}]},{"title":"浅谈JavaScript参数传递","slug":"2018-7-22-1","date":"2018-07-22T02:40:07.000Z","updated":"2020-01-20T10:14:11.419Z","comments":true,"path":"2018/07/22/2018-7-22-1/","link":"","permalink":"http://wangweijin.cn/2018/07/22/2018-7-22-1/","excerpt":"","text":"在书本中大家都学到的参数传递有两种: 按值传递和按址传递, 下面我们就来说一下 JavaScript 中的传递 按值传递非常好理解, 就不说了, 我们说一下 JavaScript 中对象的传递 前两天做了一道前端面试题, 感觉比较有趣, 特分享一下12345678910var setPerson = function(person)&#123; person.name = \"kevin\"; person = &#123;name:\"rick\"&#125;;&#125;;var person = &#123;name:\"alan\"&#125;;setPerson(person);console.log(person.name);//输出 kevin 我在做这道题时知道 person.name = &#39;kevin&#39; 是可以改变外面 person 对象的值, 所以当时也认为 person = {name: &#39;rick&#39;} 是可以改变的, 后来知道答案后感觉非常不可思议, 废了些功夫去理解一番 先来看个例子 12345678var a = &#123; name: '小王'&#125;var b = a;b = null;console.log(a);//输出 &#123;name:'小王'&#125; 我们知道 JavaScript 中的对象是引用对象, 所以 a 中存储的是对象的内存地址, 而对象存储在堆中, var b = a; 实际是将 b 的值设置为 a 对象中存储的地址, 再将 b设置为空对象 null , 也是将 b 的值改为空对象的栈内存地址, 所以说 b 的改变影响不到 a 通过上面的分析, 我们再回到题中, 向 setPerson() 函数中传递了一个对象, 可以看作是用外面的 person 对象赋值给 setPerson() 中的 person 局部对象, setPerson() 中的 person 对象只是指向了外面 person对象的地址, 当执行 person.name = &quot;kevin&quot; 时会根据对象地址访问对象, 然后修改 name 的值, 外面的person也就改变了, 但当执行 person = {name:&quot;rick&quot;}; 时, 是拿 setPerson() 中指向新的对象地址, 不会修改原来的对象 到此, 我们也就明白了对象的参数传递, 暂时没弄清这是按址传递还是按值传递, 也有人说是共享传递, 不过, 我们明白原理就好, 另外, Java 中也存在这种情况","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wangweijin.cn/categories/JavaScript/"}],"tags":[{"name":"参数传递","slug":"参数传递","permalink":"http://wangweijin.cn/tags/参数传递/"}]},{"title":"MySQL中的事务及隔离级别","slug":"2018-4-18-1","date":"2018-04-18T03:05:23.000Z","updated":"2020-01-20T10:14:11.418Z","comments":true,"path":"2018/04/18/2018-4-18-1/","link":"","permalink":"http://wangweijin.cn/2018/04/18/2018-4-18-1/","excerpt":"MySQL中InnoDB 和 MyISAM存储引擎最大的区别是InnoDB支持事务和InnoDB为行级锁、MyISAM为表级锁 一、MySQL事务及其ACID属性","text":"MySQL中InnoDB 和 MyISAM存储引擎最大的区别是InnoDB支持事务和InnoDB为行级锁、MyISAM为表级锁 一、MySQL事务及其ACID属性 原子性(Actomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。二、MySQL并行事务可能出现的问题 更新丢失：当两个或者多个事务选中同一行数据修改，由于不知道其他事务的存在，在事务提交后可能会发生更新丢失问题——最后的更新覆盖了其他事务所做的更新。 脏读：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 幻读： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行。 三、事务的隔离级别 隔离级别 脏读 不可重复读 幻读 Read uncommitted 读未提交 √ √ √ Read committed 读提交 × √ √ Repeatable read 重复读 × × √ Serializable 序列化 × × × 参考： 数据库事务隔离级别– 脏读、幻读、不可重复读清晰解释","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://wangweijin.cn/categories/MySQL/"}],"tags":[]},{"title":"MySQL中MyISAM存储引擎和InnoDB存储引擎的区别","slug":"2018-4-17-1","date":"2018-04-17T11:20:23.000Z","updated":"2020-01-20T10:14:11.418Z","comments":true,"path":"2018/04/17/2018-4-17-1/","link":"","permalink":"http://wangweijin.cn/2018/04/17/2018-4-17-1/","excerpt":"参考： MySQL存储引擎MyISAM与InnoDB区别总结整理 一、区别 InnoDB支持事务；MyISAM不支持事务。 InnoDB支持外键；MyISAM不支持外键。 InnoDB锁的粒度是行锁；MyISAM锁的粒度是表锁。 InnoDB把数据和索引存在一起；MyISAM把表分为三个文件：表结构(.frm)、表内容(MYD)、表索引(MYI)。 InnoDB不保存表的具体行数，需要通过扫描表来获取有多少行；MyISAM保存表的具体行数。 InnoDB删除表中数据时是一行一行的删除；MyISAM删除表时是先drop表，然后重建表。 InnoDB可跨平台拷贝直接使用；MyISAM很难跨平台直接使用。 InnoDB表格很难压缩；MyISAM表格可以被压缩。 InnoDB中必须包含只有该字段的索引；MyISAM表中可以和其他字段一起建立联合索引。","text":"参考： MySQL存储引擎MyISAM与InnoDB区别总结整理 一、区别 InnoDB支持事务；MyISAM不支持事务。 InnoDB支持外键；MyISAM不支持外键。 InnoDB锁的粒度是行锁；MyISAM锁的粒度是表锁。 InnoDB把数据和索引存在一起；MyISAM把表分为三个文件：表结构(.frm)、表内容(MYD)、表索引(MYI)。 InnoDB不保存表的具体行数，需要通过扫描表来获取有多少行；MyISAM保存表的具体行数。 InnoDB删除表中数据时是一行一行的删除；MyISAM删除表时是先drop表，然后重建表。 InnoDB可跨平台拷贝直接使用；MyISAM很难跨平台直接使用。 InnoDB表格很难压缩；MyISAM表格可以被压缩。 InnoDB中必须包含只有该字段的索引；MyISAM表中可以和其他字段一起建立联合索引。 注意： InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如：update table set num=1 where name like &#39;a%&#39; 二、选择MyISAM： 适用于不使用事务，对表读多写少的场景。InnoDB： 适用于可靠性要求比较高，或者要求事务，对表的写操作较多的场景。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://wangweijin.cn/categories/MySQL/"}],"tags":[]},{"title":"水管工游戏","slug":"2018-03-29-1","date":"2018-03-29T13:41:50.000Z","updated":"2020-01-20T10:14:11.418Z","comments":true,"path":"2018/03/29/2018-03-29-1/","link":"","permalink":"http://wangweijin.cn/2018/03/29/2018-03-29-1/","excerpt":"参考：《啊哈！算法》 1、题目水管工游戏是指如下图中的矩阵中，一共有两种管道，一个是直的，一个是弯的，所有管道都可以自由旋转，最终就是要连通入水口可出水口。其中的树为障碍物。","text":"参考：《啊哈！算法》 1、题目水管工游戏是指如下图中的矩阵中，一共有两种管道，一个是直的，一个是弯的，所有管道都可以自由旋转，最终就是要连通入水口可出水口。其中的树为障碍物。 2、算法思路本题使用的是深度优先搜索算法，先标识入水口方向，在每次探索新管道的时候上根据入水口方向进行扩展，然后根据管道的类型来判断下一个节点的入水口方向。 3、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package 搜索.广度优先搜索BFS.水管工游戏;import java.util.Scanner;public class Main &#123; private static int[][] map; //存储管道图 private static int n, m, top; //管道的矩阵x，y， top栈顶元素 private static boolean[][] status; //是否已使用 private static String[] stack; //栈 /** * * @param x 坐标x * @param y 坐标y * @param direction 进水口方向：1上、2右、3下、4左 */ private static void dfs(int x, int y, int direction)&#123; if(x == n-1 &amp;&amp; y == m)&#123; //如果到出口的下一个则表示完成一条路径 System.out.println(\"搜索到连通路线\"); for (int i = 0; i &lt; top;i++)&#123; System.out.print(stack[i]+\"-&gt;\"); &#125; System.out.println(); return ; &#125; if(y &lt; 0 || x &lt; 0|| x &gt; n-1 || y &gt; m-1 || status[x][y]) return; status[x][y] = true; stack[top] = \"(\"+(x+1)+\",\"+(y+1)+\",\"+direction+\")\"; //入栈 top++; if (5 &lt;= map[x][y] &amp;&amp; map[x][y] &lt;= 6)&#123; //如果是直管道 switch (direction)&#123; case 1: dfs(x+1, y, direction); break; case 2: dfs(x, y-1, direction); break; case 3: dfs(x-1, y, direction); break; case 4: dfs(x, y+1, direction); break; &#125; &#125;else&#123; switch (direction)&#123; //弯管道 case 1: dfs(x, y-1, 2); dfs(x, y+1, 4); break; case 2: dfs(x-1, y, 3); dfs(x+1, y, 1); break; case 3: dfs(x, y-1, 2); dfs(x, y+1, 4); break; case 4: dfs(x-1, y, 3); dfs(x+1, y, 1); break; &#125; &#125; status[x][y] = false; top--; &#125; public static void main(String[] ages)&#123; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); m = scanner.nextInt(); map = new int[n][m]; status = new boolean[n][m]; stack = new String[n*m]; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; map[i][j] = scanner.nextInt(); &#125; &#125; dfs(0,0, 4); &#125;&#125;/** 测试数据： 5 4 5 3 5 3 1 5 3 0 2 3 5 1 6 1 1 5 1 5 5 4 结果： 搜索到连通路线 (1,1,4)-&gt;(1,2,4)-&gt;(2,2,1)-&gt;(3,2,1)-&gt;(3,3,4)-&gt;(3,4,4)-&gt;(4,4,1)-&gt;(5,4,1)-&gt; */","categories":[{"name":"算法","slug":"算法","permalink":"http://wangweijin.cn/categories/算法/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://wangweijin.cn/tags/搜索/"},{"name":"BFS","slug":"BFS","permalink":"http://wangweijin.cn/tags/BFS/"}]},{"title":"层层递进-广度优先搜索算法","slug":"2018-03-28-2","date":"2018-03-28T13:59:01.000Z","updated":"2020-01-20T10:14:11.418Z","comments":true,"path":"2018/03/28/2018-03-28-2/","link":"","permalink":"http://wangweijin.cn/2018/03/28/2018-03-28-2/","excerpt":"广度优先搜索算法常用于通过队列求最短路径，下面只实现了搜索算法 1、算法思想广度优先搜索算法是通过一层一层的遍历的，遍历思想如下：1、 选取根节点r2、 遍历r的子节点，并计算根节点r到子节点的权值，注意的是当前节点的到根节点的权值等于当前节点的父节点到根节点的权值3、 依次遍历所有节点4、 所有节点只能遍历一遍，即当一个节点有两个父节点时，只能被一个父节点遍历","text":"广度优先搜索算法常用于通过队列求最短路径，下面只实现了搜索算法 1、算法思想广度优先搜索算法是通过一层一层的遍历的，遍历思想如下：1、 选取根节点r2、 遍历r的子节点，并计算根节点r到子节点的权值，注意的是当前节点的到根节点的权值等于当前节点的父节点到根节点的权值3、 依次遍历所有节点4、 所有节点只能遍历一遍，即当一个节点有两个父节点时，只能被一个父节点遍历 例子：先选定1节点，然后会遍历1的子节点2、3，并在遍历的时候计算2、3的权值，2的权值为1，3的权值为5，然后遍历2节点的子节点4、5，计算4、5的节点的权值为，节点4：1+7=8，节点5：1+5=6；之后遍历3节点的子节点，由于5节点已被2节点遍历，那么只遍历6号节点即可，最后其他的节点一次类推，直到遍历所有节点。 2、实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package 搜索.广度优先搜索BFS;import java.util.ArrayList;import java.util.List;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;public class Main &#123; static int[][] G = &#123; //图 &#123; 0, 1, 5, -1, -1, -1, -1, -1, -1 &#125;, &#123; 1, 0, 3, 7, 5, -1, -1, -1, -1 &#125;, &#123; 5, 3, 0, -1, 1, 7, -1, -1, -1 &#125;, &#123; -1, 7, -1, 0, 2, -1, 3, -1, -1 &#125;, &#123; -1, 5, 1, 2, 0, 3, 6, 9, -1 &#125;, &#123; -1, -1, 7, -1, 3, 0, -1, 5, -1 &#125;, &#123; -1, -1, -1, 3, 6, -1, 0, 2, 7 &#125;, &#123; -1, -1, -1, -1, 9, 5, 2, 0, 4 &#125;, &#123; -1, -1, -1, -1, -1, -1, 7, 4, 0 &#125;, &#125;; static boolean[] status = new boolean[9]; //是否被选中 private static BlockingQueue&lt;Node&gt; blockingQueue = new LinkedBlockingQueue&lt;&gt;(); //遍历队列 private static List&lt;Node&gt; list = new ArrayList&lt;&gt;(); //保存节点的信息 public static void main(String[] ages)&#123; Node node = new Node(1,0,0); blockingQueue.add(node); list.add(node); status[0] = true; while (!blockingQueue.isEmpty())&#123; Node node1 = blockingQueue.poll(); // 获取队列首元素 for (int i = 0; i &lt; G[node1.n-1].length; i++)&#123; //循环当前节点的子节点，并排除遍历过的 if (G[node1.n-1][i] != 0 &amp;&amp; G[node1.n-1][i] != -1 &amp;&amp; !status[i])&#123; Node node2 = new Node(i+1, node1.n, node1.s+G[node1.n-1][i]); blockingQueue.add(node2); list.add(node2); status[i] = true; &#125; &#125; &#125; for (Node node1: list)&#123; System.out.println(node1.n+\"-&gt;\"+node1.f+\"-&gt;\"+node1.s); &#125; &#125;&#125;class Node&#123; int n; //节点编号 int f; //父节点的编号 int s; //总权值 Node(int n, int f, int s)&#123; this.f =f; this.n = n; this.s = s; &#125;&#125;/*结果1-&gt;0-&gt;02-&gt;1-&gt;13-&gt;1-&gt;54-&gt;2-&gt;85-&gt;2-&gt;66-&gt;3-&gt;127-&gt;4-&gt;118-&gt;5-&gt;159-&gt;7-&gt;18*/","categories":[{"name":"算法","slug":"算法","permalink":"http://wangweijin.cn/categories/算法/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://wangweijin.cn/tags/搜索/"}]},{"title":"不撞南墙不回头-深度优先搜索算法","slug":"2018-03-28-1","date":"2018-03-28T00:53:17.000Z","updated":"2020-01-20T10:14:11.418Z","comments":true,"path":"2018/03/28/2018-03-28-1/","link":"","permalink":"http://wangweijin.cn/2018/03/28/2018-03-28-1/","excerpt":"深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search，主要用于穷举所有情况的题目，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次. 今天介绍算法实现的两种形式，一种是通过数组交换位置、一种是通过数组保存元素是否被使用","text":"深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search，主要用于穷举所有情况的题目，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次. 今天介绍算法实现的两种形式，一种是通过数组交换位置、一种是通过数组保存元素是否被使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package 搜索.深度优先搜索DFS;public class Main &#123; public static int count = 0; //统计数量 //数组交换方式 public static void dfs1(int[] a,int n)&#123; if(n == a.length-1)&#123; //判断是否到达数组结尾 count++; printArray(a); return; &#125; for (int i = n; i &lt; a.length; i++)&#123; &#123;a[i] = a[n] ^ a[i];a[i] = a[n] ^ a[i];a[n] = a[n] ^ a[i];&#125; //交换位置 dfs1(a,n+1); &#123;a[i] = a[n] ^ a[i];a[i] = a[n] ^ a[i];a[n] = a[n] ^ a[i];&#125; &#125; &#125; //数组存储状态方式 public static int[] status; //存储状态的数组 public static void dfs2(int[] a, int n)&#123; if(n == a.length)&#123; count++; printArray(a); return ; &#125; for (int i = 1; i &lt;= a.length;i++)&#123; if(status[i] == 0)&#123; a[n] = i; status[i] = 1; //1表示该数已被使用；0表示未使用 dfs2(a, n+1); status[i] = 0; &#125; &#125; &#125; //输出排列结果 public static void printArray(int[] a)&#123; for (int i = 0; i &lt; a.length; i++)&#123; System.out.print(a[i]); &#125; System.out.println(); &#125; public static void main(String[] ages)&#123; int[] a = new int[6]; //方式一 需要初始排列下数组 for (int i = 1; i &lt;= a.length; i++) a[i-1] = i; dfs1(a, 0); status = new int[6+1]; dfs2(a, 0); System.out.println(count); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wangweijin.cn/categories/算法/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://wangweijin.cn/tags/搜索/"},{"name":"全排列","slug":"全排列","permalink":"http://wangweijin.cn/tags/全排列/"}]},{"title":"交换两个变量的值","slug":"2018-03-27-01","date":"2018-03-27T07:33:36.000Z","updated":"2020-01-20T10:14:11.418Z","comments":true,"path":"2018/03/27/2018-03-27-01/","link":"","permalink":"http://wangweijin.cn/2018/03/27/2018-03-27-01/","excerpt":"三种交换方法 1、通过中间变量交换12345public void swap(int a, int b)&#123; int tmp = a; a = b; b = tmp;&#125;","text":"三种交换方法 1、通过中间变量交换12345public void swap(int a, int b)&#123; int tmp = a; a = b; b = tmp;&#125; 2、通过加减交换123456//该方法两数相加可能会超出int范围而损失精度public void swap(int a, int b)&#123; a = a + b; b = a - b; b = a - b;&#125; 3、通过异或交换123456// 该方法是最高效的方法，也不会超出int的范围public void swap(int a, int b)&#123; a = a ^ b; b = a ^ b; a = a ^ b;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wangweijin.cn/categories/算法/"}],"tags":[]},{"title":"Ubuntu 安装 最新版本的 PHP","slug":"2018-03-09-1","date":"2018-03-09T08:20:19.000Z","updated":"2020-01-20T10:14:11.418Z","comments":true,"path":"2018/03/09/2018-03-09-1/","link":"","permalink":"http://wangweijin.cn/2018/03/09/2018-03-09-1/","excerpt":"1. 准备工作12345//解决有可能存在的语言问题sudo apt install -y language-pack-en-basesudo locale-gen en_US.UTF-8export LANG=en_US.UTF-8export LC_ALL=en_US.UTF-8","text":"1. 准备工作12345//解决有可能存在的语言问题sudo apt install -y language-pack-en-basesudo locale-gen en_US.UTF-8export LANG=en_US.UTF-8export LC_ALL=en_US.UTF-8 2. 添加最新的PHP源123456//添加php的仓库sudo apt-get install -y software-properties-common//中途按下回车,添加源sudo add-apt-repository ppa:ondrej/phpsudo apt-get update 3. 安装相应版本的PHP12//这里以安装PHP7.2为例sudo apt-get install -y php7.2 php7.2-mysql php7.2-curl php7.2-xml php7.2-mcrypt php7.2-json php7.2-gd php7.2-mbstring OK,完成。","categories":[{"name":"教程","slug":"教程","permalink":"http://wangweijin.cn/categories/教程/"}],"tags":[{"name":"php","slug":"php","permalink":"http://wangweijin.cn/tags/php/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://wangweijin.cn/tags/ubuntu/"}]},{"title":"Mysql 高效的存储IPv4地址 inet_aton   inet_ntoa","slug":"2018-03-01-1","date":"2018-03-01T07:10:33.000Z","updated":"2020-01-20T10:14:11.417Z","comments":true,"path":"2018/03/01/2018-03-01-1/","link":"","permalink":"http://wangweijin.cn/2018/03/01/2018-03-01-1/","excerpt":"IPv4的地址人们通常使用的是varchar(15)列来存储IP地址。mysql可以使用无符号整数来存储，myql提供inet_aton()和inet_ntoa()来互相转换。 使用 inet_aton() 存储IP地址可以使用无符号的int 就可以存储了。12//创建数据库create table a(ip int unsigned);","text":"IPv4的地址人们通常使用的是varchar(15)列来存储IP地址。mysql可以使用无符号整数来存储，myql提供inet_aton()和inet_ntoa()来互相转换。 使用 inet_aton() 存储IP地址可以使用无符号的int 就可以存储了。12//创建数据库create table a(ip int unsigned); 使用 inet_aton向数据库中添加ip地址1insert into a values(inet_aton(&apos;255.255.255.255&apos;)), (inet_aton(&apos;192.168.1.1&apos;)); 查询数据1select * from a where ip=inet_aton(&apos;192.168.1.1&apos;); 使用 inet_aton() 来显示数据 select inet_ntoa(ip) from a; 使用int来存储ip可以加快通过ip查找的速度。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wangweijin.cn/categories/mysql/"}],"tags":[{"name":"优化存储","slug":"优化存储","permalink":"http://wangweijin.cn/tags/优化存储/"}]},{"title":"排序-快速排序","slug":"2018-02-24-3","date":"2018-02-24T13:26:59.000Z","updated":"2020-01-20T10:14:11.417Z","comments":true,"path":"2018/02/24/2018-02-24-3/","link":"","permalink":"http://wangweijin.cn/2018/02/24/2018-02-24-3/","excerpt":"1. 算法思路 \b快速排序是\b常用的、平均时间复杂度为 O(NlogN) 的\b排序算法 快速排序算法的思路是\b首先选取一个基准数，然后以这个数为基准，将数列中大于这个数的放到该数\b的右边，小于该数\b的放到左边，然后\b两边在各选一个基准数，再依次排序。","text":"1. 算法思路 \b快速排序是\b常用的、平均时间复杂度为 O(NlogN) 的\b排序算法 快速排序算法的思路是\b首先选取一个基准数，然后以这个数为基准，将数列中大于这个数的放到该数\b的右边，小于该数\b的放到左边，然后\b两边在各选一个基准数，再依次排序。 2. 实现代码首先运用的事递归的方法，需要传入数组最左边的和最右边的下标，选取最左边的数为基准数，然后最右边的下标依次向前比较，直到遇到一个比基准书小的数或者当前左边下标大于右边下标\b时停止比较，然后最左边基准书依次向右边比较，直到遇到一个比基准数大的数或者当前左边下标大于右边下标时停止比较，交换两数的位置，继续从右边\b左边开始进行上述\b操作，直到左边下标等于右边下标，然后将基准数和左边下标对应的数交换位置，最后以\bleft、i-1作为左边待排序序列，以i+1、right作为右边带排序序列继续用此方法排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Scanner;public class Main &#123; public static int[] nums; public static void quicksort(int left, int right)&#123; if(left &gt; right) return; int i = left, // 左边的哨兵 j = right, // 右边的哨兵 tmp = nums[left]; //基准数 while (i &lt; j)&#123; while (tmp &lt;= nums[j] &amp;&amp; i &lt; j) j--; while (tmp &gt;= nums[i] &amp;&amp; i &lt; j) i++; if(i &lt; j)&#123; int n = nums[i]; nums[i] = nums[j]; nums[j] = n; &#125; &#125; nums[left] = nums[i]; nums[i] = tmp; quicksort(left, i-1); quicksort(i+1, right); &#125; public static void main(String[] ages)&#123; Scanner scanner = new Scanner(System.in); nums = new int[scanner.nextInt()]; for (int i = 0; i &lt; nums.length; i++)&#123; nums[i] = scanner.nextInt(); &#125; quicksort(0, nums.length-1); for (int i = 0; i &lt; nums.length; i++)&#123; System.out.print(nums[i]+\" \"); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wangweijin.cn/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://wangweijin.cn/tags/排序/"}]},{"title":"PHP 中对象的复制","slug":"2018-02-24-2","date":"2018-02-24T11:44:05.000Z","updated":"2020-01-20T10:14:11.417Z","comments":true,"path":"2018/02/24/2018-02-24-2/","link":"","permalink":"http://wangweijin.cn/2018/02/24/2018-02-24-2/","excerpt":"PHP中的对象在复制是通过 clone 来复制对象的 12345678910111213141516171819202122232425262728293031&lt;?phpclass A&#123; public static $n = 0; public $s; public function __construct()&#123; $this-&gt;s = ++self::$n; &#125;&#125;$a1 = new A();$a1-&gt;s = -1;$a2 = $a1;echo $a1-&gt;s;echo '&lt;br&gt;';echo $a2-&gt;s;/** * 输出 * -1 * -1 */$a1 = new A();$a2 = clone $a1;$a1-&gt;s = -1;echo $a1-&gt;s;echo '&lt;br&gt;';echo $a2-&gt;s;/** * 输出 * -1 * 2 */","text":"PHP中的对象在复制是通过 clone 来复制对象的 12345678910111213141516171819202122232425262728293031&lt;?phpclass A&#123; public static $n = 0; public $s; public function __construct()&#123; $this-&gt;s = ++self::$n; &#125;&#125;$a1 = new A();$a1-&gt;s = -1;$a2 = $a1;echo $a1-&gt;s;echo '&lt;br&gt;';echo $a2-&gt;s;/** * 输出 * -1 * -1 */$a1 = new A();$a2 = clone $a1;$a1-&gt;s = -1;echo $a1-&gt;s;echo '&lt;br&gt;';echo $a2-&gt;s;/** * 输出 * -1 * 2 */ 说到 clone 复制，clone复制会对对象的所有属性执行一个浅复制。所有的引用属性 仍然会是一个指向原来的变量的引用，要想实现复制需要 __clone 魔术方法。在下面例子的输出中可以看出，a1 在 __clone 方法中进行了clone,所以两个b中的a1值发生了变话，成为了两个不同的对象。而a2没有进行设置，所以值一样，还是同一个对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpclass A&#123; public static $n = 0; public $s; public function __construct()&#123; $this-&gt;s = ++self::$n; &#125; public function __clone() &#123; $this-&gt;s = ++ self::$n; &#125;&#125;class B&#123; public $a1; public $a2; public function __clone() &#123; $this-&gt;a1 = clone $this-&gt;a1; //$this-&gt;a2 = clone $this-&gt;a2; //省略a2的复制 &#125;&#125;$b1 = new B();$b1-&gt;a1 = new A();$b1-&gt;a2 = new A();$b2 = clone $b1;var_dump($b1);var_dump($b2);/* 输出 /Applications/MAMP/htdocs/PHP学习/面向对象/对象复制/demo2.php:31: object(B)[1] public 'a1' =&gt; object(A)[2] public 's' =&gt; int 1 public 'a2' =&gt; object(A)[3] public 's' =&gt; int 2 /Applications/MAMP/htdocs/PHP学习/面向对象/对象复制/demo2.php:32: object(B)[4] public 'a1' =&gt; object(A)[5] public 's' =&gt; int 3 public 'a2' =&gt; object(A)[3] public 's' =&gt; int 2 */","categories":[{"name":"PHP","slug":"PHP","permalink":"http://wangweijin.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://wangweijin.cn/tags/PHP/"},{"name":"对象复制","slug":"对象复制","permalink":"http://wangweijin.cn/tags/对象复制/"}]},{"title":"使用hexo+GitHub搭建的个人博客 文件备份","slug":"2018-02-24-1","date":"2018-02-24T08:51:30.000Z","updated":"2020-01-20T10:14:11.417Z","comments":true,"path":"2018/02/24/2018-02-24-1/","link":"","permalink":"http://wangweijin.cn/2018/02/24/2018-02-24-1/","excerpt":"使用hexo可以方便的搭建自己的个人博客，但是由于博客的 markdown 文件都放在本地。可能会容易丢失，备份起来也会很麻烦。本教程就是实现方便的文件备份。 1. hexo+GitHub 搭建个人博客","text":"使用hexo可以方便的搭建自己的个人博客，但是由于博客的 markdown 文件都放在本地。可能会容易丢失，备份起来也会很麻烦。本教程就是实现方便的文件备份。 1. hexo+GitHub 搭建个人博客 搭建个人可博客的步骤就不在说了，网上很多，大家可自行查找。搭建完成后效果如下 2. 在GitHub中创建 hexo 分支来存储本地 markdown 文件在本地文件根目录创建 .gitignore 文件，若存在修改为123456.DS_Store*.lognode_modules/.deploy*/public/db.json 在本地文件根目录中初始化 git1git init 创建分支hexo1git checkout -b hexo 提交到仓库，需要注意的事在提交之前要把themes目录下主题中的 .git 文件夹重命名或者删除，不然的话 git 会把主题当做子模块来处理。 12git add .git commit -m &apos;init&apos; 添加远程仓库1git remote add origin git@github.com:MrWangwj/MrWangwj.github.io.git push 到远程分支1git push origin hexo 3. 在另一台电脑上使用首先要克隆下这个项目1git clone git@github.com:MrWangwj/MrWangwj.github.io.git 进入博客目录1cd MrWangwj.github.io.git 切换到博客文件分支1git checkout -b hexo origin/hexo 安装hexo1npm install hexo --save 然后编辑、查看12hexo g //编译hexo s //浏览器查看 localhost:4000 提交 git，若在提交过程中出现 ERROR Deployer not found: git 可执行 npm install hexo-deployer-git --save 后重新提交。1hexo d 在写了新 markdown 文件后提交 git123git add .git commit -m &apos;新增博客&apos;git push origin hexo 到此，我们以后只要写完博客发布后记得 push 一下就能实现备份了。","categories":[{"name":"教程","slug":"教程","permalink":"http://wangweijin.cn/categories/教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wangweijin.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://wangweijin.cn/tags/github/"}]},{"title":"Hello Word","slug":"2018-02-07-1","date":"2018-02-07T02:42:30.000Z","updated":"2020-01-20T10:14:11.417Z","comments":true,"path":"2018/02/07/2018-02-07-1/","link":"","permalink":"http://wangweijin.cn/2018/02/07/2018-02-07-1/","excerpt":"","text":"第一篇博客1234function test()&#123; echo 'Hello word';&#125;test();","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://wangweijin.cn/tags/test/"}]}]}