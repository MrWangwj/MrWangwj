---
title: MySQL中的事务及隔离级别
date: 2018-04-18 11:05:23
categories: MySQL
---

> MySQL中InnoDB 和 MyISAM存储引擎最大的区别是InnoDB支持事务和InnoDB为行级锁、MyISAM为表级锁

#### 一、MySQL事务及其ACID属性

<!-- more -->

* 原子性(Actomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
* 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
* 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
* 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。
#### 二、MySQL并行事务可能出现的问题
*  **更新丢失：**当两个或者多个事务选中同一行数据修改，由于不知道其他事务的存在，在事务提交后可能会发生更新丢失问题——最后的更新覆盖了其他事务所做的更新。
*  **脏读：**一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
*  **不可重复读：**是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
*  **幻读：** 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行。

#### 三、事务的隔离级别
隔离级别|脏读|不可重复读|幻读
 :- | :-: | :-: | :-: 
Read uncommitted 读未提交 | √ | √ | √
Read committed 读提交 | × | √ | √
Repeatable read 重复读 | × | × | √
Serializable 序列化 | × | × | ×

参考： [ 数据库事务隔离级别-- 脏读、幻读、不可重复读清晰解释 ](https://blog.csdn.net/jiesa/article/details/51317164)